#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use IPC::Open3 qw(open3);
use IO::Handle;
use POSIX qw(strftime);
use Time::HiRes qw(alarm time);

my $screenDaemonConf = "$ENV{HOME}/.config/screen-daemon.conf";
my $logBaseDir = "$ENV{HOME}/.cache/logs";

my $EXEC = basename $0;

my $PRINT_TO_STDOUT = 1;

my $usage = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC NAME --start
    read $screenDaemonConf and find a line of the form:
      NAME DELAY_MILLIS TIMEOUT_MILLIS CMD [ARG ARG ..]
    invoke $EXEC NAME --start DELAY_MILLIS TIMEOUT_MILLIS CMD [ARG ARG ..]

  $EXEC NAME --start DELAY_MILLIS TIMEOUT_MILLIS CMD [ARG ARG ..]
    -quit screen session 'NAME'
      screen -S NAME -X quit
    -start a screen session named 'NAME' that runs `$EXEC --run`
      screen -S NAME -d -m \\
        $EXEC NAME --run DELAY_MILLIS TIMEOUT_MILLIS \\
          CMD [ARG ARG ..]

  $0 NAME --run DELAY_MILLIS TIMEOUT_MILLIS CMD [ARG ARG ..]
    -start logging to LOG_FILE
    -create symlink to LOG_FILE at $logBaseDir/<NAME>/latest
    -run 'CMD [ARG ARG ..]' every DELAY_MILLIS (if DELAY_MILLIS == 0, exit after first run)
    -append STDOUT/STDERR to LOG_FILE
    -if CMD takes longer than TIMEOUT_MILLIS, kill it (never kill it if TIMEOUT_MILLIS is 0)

      LOG_FILE = $logBaseDir/<NAME>/<START_MILLIS>.log
      START_MILLIS = time in milliseconds at initial start

  $EXEC NAME
  $EXEC NAME --attach
    -attach to screen session 'NAME'
      screen -S NAME -d r

  $EXEC NAME --stop|--exit|--quit|--kill
    -quit screen session 'NAME'
      screen -S NAME -X quit

  $EXEC NAME --tail
    -tail the 'latest' log file symlink for NAME
      tail -F $logBaseDir/NAME/latest

  NAME
    screen session name, must be letters, numbers, underscores, or hyphens only

  DELAY_MILLIS
    positive integer for milliseconds to wait between commands,
      or '0' for run only once
    if delay and timeout are non-zero, the maximum delay between commands is:
      DELAY_MILLIS + TIMEOUT_MILLIS

  TIMEOUT_MILLIS
    positive integer for milliseconds to wait before killing command,
      or '0' for never kill command
    if delay and timeout are non-zero, the maximum delay between commands is:
      DELAY_MILLIS + TIMEOUT_MILLIS
";

sub parseScreenDaemonConf();
sub checkRunArgs($$$@);
sub runCommandForever($$$@);
sub cmdTimeout($$@);
sub logMsg($$);
sub shellParse($);

sub main(@){
  if(@_ == 1 and $_[0] =~ /^(-h|--help)$/){
    print $usage;
    exit 0;
  }elsif(@_ == 2 and $_[1] =~ /^--start$/){
    my ($name, $startArg) = @_;
    my $conf = ${parseScreenDaemonConf()}{$name};
    if(not defined $conf){
      die "no entry in $screenDaemonConf found for $name\n";
    }
    my $delayMillis = $$conf{delayMillis};
    my $timeoutMillis = $$conf{timeoutMillis};
    my @cmd = shellParse $$conf{cmdStr};
    print "$name --start $delayMillis $timeoutMillis @cmd\n";

    checkRunArgs $name, $delayMillis, $timeoutMillis, @cmd;
    system "screen -S $name -X quit >/dev/null";
    system "screen", "-S", $name, "-d", "-m",
      $0, $name, "--run", $delayMillis, $timeoutMillis, @cmd;
  }elsif(@_ > 4 and $_[1] =~ /^--start$/){
    my ($name, $startArg, $delayMillis, $timeoutMillis, @cmd) = @_;
    checkRunArgs $name, $delayMillis, $timeoutMillis, @cmd;
    system "screen -S $name -X quit >/dev/null";
    system "screen", "-S", $name, "-d", "-m",
      $0, $name, "--run", $delayMillis, $timeoutMillis, @cmd;
  }elsif(@_ > 4 and $_[1] =~ /^--run$/){
    my ($name, $runArg, $delayMillis, $timeoutMillis, @cmd) = @_;
    checkRunArgs $name, $delayMillis, $timeoutMillis, @cmd;
    runCommandForever $name, $delayMillis, $timeoutMillis, @cmd;
  }elsif(@_ == 2 and $_[1] =~ /^(--tail)$/){
    my ($name) = @_;
    die "$usage\ninvalid name: $name\n" if $name !~ /^[a-zA-Z0-9_\-]+$/;
    exec "tail", "-F", "$logBaseDir/$name/latest";
  }elsif(@_ == 2 and $_[1] =~ /^(--stop|--exit|--quit|--kill)$/){
    my ($name) = @_;
    die "$usage\ninvalid name: $name\n" if $name !~ /^[a-zA-Z0-9_\-]+$/;
    system "screen", "-S", $name, "-X", "quit";
  }elsif(@_ == 1 or (@_ == 2 and $_[1] =~ /^(--attach)$/)){
    my ($name) = @_;
    die "$usage\ninvalid name: $name\n" if $name !~ /^[a-zA-Z0-9_\-]+$/;
    system "screen", "-S", $name, "-d", "-r"
  }else{
    die $usage;
  }
}

sub parseScreenDaemonConf(){
  my $confs = {};
  return $confs if not -f $screenDaemonConf;
  for my $line(`cat $screenDaemonConf`){
    chomp $line;
    next if $line =~ /^\s*(#.*)?$/; #skip empty or comment-only lines
    if($line =~ /^([a-zA-Z0-9_\-]+)\s+(\d+)\s+(\d+)\s+(.+)$/){
      my ($name, $delayMillis, $timeoutMillis, $cmdStr) = ($1, $2, $3, $4);
      $$confs{$name} = {
        name => $name,
        delayMillis => $delayMillis,
        timeoutMillis => $timeoutMillis,
        cmdStr => $cmdStr,
      };
    }else{
      die "malformed conf line: $line\n";
    }
  }
  return $confs;
}

sub checkRunArgs($$$@){
  my ($name, $delayMillis, $timeoutMillis, @cmd) = @_;
  if($name !~ /^[a-zA-Z0-9_\-]+$/){
    die "$usage\ninvalid name: $name\n";
  }elsif($delayMillis !~ /^\d+$/ or $delayMillis < 0){
    die "$usage\ninvalid delayMillis: $delayMillis\n"
  }elsif($timeoutMillis !~ /^\d+$/ or $timeoutMillis < 0){
    die "$usage\ninvalid timeoutMillis: $timeoutMillis\n"
  }elsif(@cmd == 0){
    die "$usage\nmissing CMD\n";
  }
}

sub runCommandForever($$$@){
  my ($name, $delayMillis, $timeoutMillis, @cmd) = @_;
  my $nowMillis = int(time * 1000.0);
  my $logFileName = "$name-$nowMillis.log";

  my $logDir = "$logBaseDir/$name";
  system "mkdir", "-p", $logDir;
  my $logFile = "$logDir/$logFileName";
  system "touch", $logFile;

  system "rm", "-f", "$logDir/latest";
  system "ln", "-s", $logFileName, "$logDir/latest";

  if($timeoutMillis > 0){
    $SIG{ALRM} = sub {die "timeout"};
  }

  my $logFH;
  if($PRINT_TO_STDOUT){
    open $logFH, "|-", "tee -a $logFile" or die "Could not tee logFH to $logFile\n";
  }else{
    open $logFH, ">>", $logFile or die "Could not append to $logFile\n";
  }

  logMsg($logFH, "started $name daemon");
  while(1){
    logMsg($logFH, "running command: @cmd");
    logMsg($logFH, "command start");

    cmdTimeout $logFH, $timeoutMillis, @cmd;

    logMsg($logFH, "command end");

    print $logFH "\n\n\n";
    $logFH->flush();

    if($delayMillis > 0){
      sleep $delayMillis/1000.0;
    }else{
      last;
    }
  }
}

sub cmdTimeout($$@){
  my ($logFH, $timeoutMillis, @cmd) = @_;

  my $logFileno = fileno $logFH;
  my $pid = open3(undef, ">&$logFileno", ">&$logFileno", @cmd);
  if($timeoutMillis > 0){
    eval {
      alarm $timeoutMillis/1000.0;
      waitpid $pid, 0;
      alarm 0;
    };
    if($@ =~ /timeout/){
      print $logFH "TIMEOUT pid=$pid after ${timeoutMillis}ms\n";
      system "kill", "-9", "$pid";
      waitpid $pid, 0;
    }
  }else{
    waitpid $pid, 0;
  }
}

sub logMsg($$){
  my ($logFH, $msg) = @_;

  my $now = time;
  my @localtime = localtime($now);
  my $millis = sprintf "%03d", int($now * 1000 + 0.5) % 1000;
  my $dateFmt = strftime("%Y-%m-%d %H:%M:%S.$millis %z", @localtime);

  chomp $msg;

  print $logFH "%%%|$EXEC|$dateFmt|$msg\n";
}

sub shellParse($){
  my ($str) = @_;
  my @words = `for x in $str; do echo \$x; done`;
  chomp foreach @words;
  return @words;
}

&main(@ARGV);
