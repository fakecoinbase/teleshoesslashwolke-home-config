#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);

sub addLap();
sub readLaps();
sub parseLaps($);
sub timeUnitToMillis($);
sub floor($);
sub round($);
sub nowMillis();

my $EXEC = basename $0;
my $DIR = "$ENV{HOME}/.cache/lap";

my $MAX_LAP_LEN_4HR = "4hr";

my $CMD_READ = "read";
my $CMD_APPEND = "append";


my $usage = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC
  $EXEC -a | --append | -p | --put
    append the date to $DIR/<YYYYMMDD>,
    formatted \"<MILLIS> #<DATE-FMT>\"

  $EXEC [OPTS] -g | --get | -r | --read
    -read all dates in $DIR/*
    -parse into millisecond timestamps
    -split into max $MAX_LAP_LEN_4HR <LAP_GROUP>s:
       -each date in each group is within $MAX_LAP_LEN_4HR of the next-latest date in the group
       -each date in each group is at least $MAX_LAP_LEN_4HR after or before every date in every other group
    -format each LAP_GROUP, one per line

  OPTS
    -c | --cur | --last
      print only the last group, followed by a newline
    --all
      print all groups, each followed by a newline (this is the default)

";

sub main(@){
  my $cmd = $CMD_APPEND;
  my $lastGroupOnly = 0;
  while(@_ > 0 and $_[0] =~ /^-/){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(-a|--append|-p|--put)$/){
      $cmd = $CMD_APPEND;
    }elsif($arg =~ /^(-g|--get|-r|--read)$/){
      $cmd = $CMD_READ;
    }elsif($arg =~ /^(-c|--cur|--last)$/){
      $lastGroupOnly = 1;
    }elsif($arg =~ /^(--all)$/){
      $lastGroupOnly = 0;
    }else{
      die "$usage\nERROR: unknown arg: $arg\n";
    }
  }

  if($cmd eq $CMD_APPEND){
    addLap();
  }elsif($cmd eq $CMD_READ){
    my $groups = parseLaps(readLaps());
    if($lastGroupOnly){
      $groups = [$$groups[-1]];
    }
    for my $group(@$groups){
      my $fmt = "@$group";
      print "$fmt\n";
    }
  }else{
    die "$usage\nERROR: unknown command: $cmd\n";
  }
}

sub addLap(){
  my $nowMillis = nowMillis();
  my $nowEpoch = round($nowMillis / 1000.0);

  my $nowYYYYMMDD = `date --date=\@$nowEpoch +%Y%m%d`;
  chomp $nowYYYYMMDD;

  my $nowFmt = `date --date=\@$nowEpoch`;
  chomp $nowFmt;

  my $destFile = "$DIR/$nowYYYYMMDD";
  open FH, ">> $destFile" or die "ERROR: could not append to $destFile\n$!\n";
  print FH "$nowMillis #$nowFmt\n";
  close FH;
}

sub readLaps(){
  die "ERROR: $DIR is not a dir\n" if not -d $DIR;
  my @files = glob "$DIR/*";
  die "ERROR: no files in $DIR/\n" if @files == 0;
  my @dates = `cat @files`;
  my $millis = [];
  for my $d(@dates){
    chomp $d;
    if($d =~ /^(\d{10})\s*(#.*)?$/){
      push @$millis, int($1 * 1000);
    }elsif($d =~ /^(\d{13})\s*(#.*)?$/){
      push @$millis, int($1);
    }else{
      my $epoch = `date --date="$d" +%s`;
      chomp $epoch;
      if($epoch =~ /^\d{10}$/){
        push @$millis, int($epoch * 1000);
      }else{
        die "ERROR: could not parse date: $d\n";
      }
    }
  }
  return $millis;
}

sub parseLaps($){
  my ($millis) = @_;
  my $maxLapMillis = timeUnitToMillis $MAX_LAP_LEN_4HR;

  my $groups = [];
  my $curGroup = undef;
  my $prev;
  #split out laps into groups with at least MAX_LAP_LEN_4HR between them
  for my $m(@$millis){
    if(defined $prev and $m-$prev > $maxLapMillis){
      $curGroup = undef;
    }
    if(not defined $curGroup){
      $curGroup = [];
      push @$groups, $curGroup;
    }
    push @$curGroup, $m;
    $prev = $m;
  }

  return $groups;
}
sub timeUnitToMillis($){
  my ($s) = @_;
  if($s =~ /^(\d+)(\w+)$/){
    my ($val, $unit) = ($1, $2);
    if($unit =~ /^(ms|millis|millisecond|milliseconds)$/){
      return int($val);
    }elsif($unit =~ /^(s|sec|secs|sex|second|seconds)$/){
      return int($val * 1000);
    }elsif($unit =~ /^(m|min|mins|minute|minutes)$/){
      return int($val * 1000 * 60);
    }elsif($unit =~ /^(h|hr|hrs|hour|hours)$/){
      return int($val * 1000 * 60 * 60);
    }
  }
  die "ERROR: could not parse time unit $s\n";
}


sub floor($){
  return int($_[0]);
}
sub round($){
  return floor($_[0] + 0.5);
}

sub nowMillis(){
  return round(time*1000.0);
}

&main(@ARGV);
